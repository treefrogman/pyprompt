#!/usr/bin/python
# "nÃ¸de" is backronymed to "nÃ¸de operating / development environment", but it is also a portmanteaux of "no code", with the added symbology of the crossed out circle to signify the lack of coding: utf-8

import os
import sys
import getpass
from datetime import datetime

#importlib.import_module( "batterylevel" )

def batterylevel():
	profile = os.popen( "ioreg -r -c AppleSmartBattery", 'r' ).read()

	for line in profile.split( "\n" ):
		if 'CurrentCapacity' in line:
			curline = line
		elif 'MaxCapacity' in line:
			maxline = line
		elif 'ExternalChargeCapable' in line:
			chgline = line


	chg = { "Yes": "âš¡", "No": "%" }[ chgline.split( " " )[ -1 ] ]
	cur = int( curline.split( " " )[ -1 ] )
	max = int( maxline.split( " " )[ -1 ] )

	# eighths = [
	# 	"0",
	# 	"â…›",
	# 	"Â¼",
	# 	"â…œ",
	# 	"Â½",
	# 	"â…",
	# 	"Â¾",
	# 	"â…"
	# ]
	# print chg + eighths[ ( ( 16 * cur / max ) - 1 ) / 2 ]

	return chg + str( 100 * cur / max )



def emojiclock():
	time = datetime.now()

	times = [
		"ğŸ•›",
		"ğŸ•§",
		"ğŸ•",
		"ğŸ•œ",
		"ğŸ•‘",
		"ğŸ•",
		"ğŸ•’",
		"ğŸ•",
		"ğŸ•“",
		"ğŸ•Ÿ",
		"ğŸ•”",
		"ğŸ• ",
		"ğŸ••",
		"ğŸ•¡",
		"ğŸ•–",
		"ğŸ•¢",
		"ğŸ•—",
		"ğŸ•£",
		"ğŸ•˜",
		"ğŸ•¤",
		"ğŸ•™",
		"ğŸ•¥",
		"ğŸ•š",
		"ğŸ•¦"
	]

	return times[ ( time.hour % 12 ) * 2 + ( time.minute + 15 ) / 30 ]












rows, columns = map( lambda s: int( s ), os.popen('stty size', 'r').read().split() )

s = {
	'topLeft': '\033[0;0H\]',
	'bottomLeft': '\033[100;0H',
	'inv': '\033[7m',
	'bold': '\033[1m',
	'reset': '\033[0m',
	'clearLine': '\033[K',
	'upOne': '\033[1A',
	'inField': '\033[' + str( int( rows ) - 1 ) + ';3H',
	'outputPosition': '\033[' + str( int( rows ) ) + ';1H',
	'spaceLine': ' ' * ( int( columns ) - 1 ),
	'horizontalRule': 'â”' * ( int( columns ) - 6 ),
	'newline': '\n'
}

v = {
	'cwd': "/" if os.path.abspath( os.getcwd() ) == "/" else
		( "~" if (
			os.path.abspath( os.getcwd() ) == os.environ[ 'HOME' ]
		) else os.path.split( os.getcwd() )[ 1 ] ),
	'user': getpass.getuser()
}
def end_prompt():
	#print s['outputPosition']
	sys.stdout.write( s[ 'reset' ] )

def begin_prompt():
	StatusBar = s[ 'inv' ] + "â”ƒ".join( [
		batterylevel(),
		datetime.today().strftime( "ğŸ“… %y%m%dâ”ƒ" + emojiclock() + " %H%M%S" ),
		"ğŸ‘¤ " + v["user"],
		"ğŸ“‚ " + v["cwd"]
	] ) + s['reset']
	DashPad = 'â”' * ( ( columns - len( StatusBar.decode( 'utf-8' ) ) ) / 2 )
	TopRow = 'â”' + DashPad + 'â•¸' + StatusBar + 'â•º' + DashPad + 'â”“'
	MidRow = 'â”ƒ' + ' ' * ( columns - 3 ) + 'â”ƒ'
	EndRow = 'â”—' + 'â”' * ( columns - 3 ) + 'â”›'

	#print UpOne + HorizontalRule + TopLeft + Invert + StatusBar + BottomLeft + SpaceLine + BottomLeft + columns
	#print Invert + StatusBar + Newline + Reset + SpaceLine + BottomLeft + Newline + HorizontalRule + InField
	#print s['newline'].join( [ TopRow, MidRow, EndRow ] ) + s['inField']
	print s[ 'newline' ].join( [ StatusBar, s[ 'bold' ] ] )


		# PS1=""
	#
	# 	mycols=$(tput cols)
	# 	mylines=$(tput lines)
	#
	#     local Reset='\[\e[0m\]'
	#
	#     local Invert='\[\e[7m\]'
	#     local Red='\[\e[0;31m\]'
	#     local Gre='\[\e[0;32m\]'
	#     local BYel='\[\e[1;33m\]'
	#     local BBlu='\[\e[1;34m\]'
	#     local Pur='\[\e[0;35m\]'
	#     local TopLeft='\[\e[0;0H\]'
	#     local BottomLeft='\[\e[$mylines;0H\]'
	#     local ClearLine='\[\e[K\]'
	#     #HorizontalRule='\$(printf 'â”€%.0s' {1..1000} | cut -c1-$(( $mycols )))
	#     #local HorizontalRule=`tail -c $(( $cols * 3 - 8 ))
	# 	local SpaceyRule=$( printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' - )
	# 	#'%*s\n' "${COLUMNS:-$mycols}" '' | tr ' ' - )
	#
	#
	# 	#printf ' %.0s' {1..1000} | cut -c1-$(( ${COLUMNS} )))
	#
	#
	# 	#PS1+=$HorizontalRule"\n"
	# 	PS1+=$TopLeft$Invert$mycols"ğŸ’» \lâ”ƒ\$(batterylevel)â”ƒ\$(emojiclock) \D{%y%m%d.%H%M%S}â”ƒğŸ‘¤ \uâ”ƒğŸ“‚ \W"$Reset$BottomLeft
	# 	PS1+=$Invert$SpaceyRule$BottomLeft
	# 	PS1+="$ "
	#}

	#trap 'echo -ne "\033[0m\033[1000;0H"' DEBUG
	#trap '' DEBUG

	# PROMPT_COMMAND=__prompt_command # Func to gen PS1 after CMDs
	#
	# __prompt_command() {
	#     local EXIT="$?"             # This needs to be first
	#     PS1=""
	#
	#     local Reset='\[\e[0m\]'
	#
	#     local Red='\[\e[0;31m\]'
	#     local Gre='\[\e[0;32m\]'
	#     local BYel='\[\e[1;33m\]'
	#     local BBlu='\[\e[1;34m\]'
	#     local Pur='\[\e[0;35m\]'
	#
	#     if [ $EXIT != 0 ]; then
	#         PS1+="${Red}\u${Reset}"      # Add red if exit code non 0
	#     else
	#         PS1+="${Gre}\u${Reset}"
	#     fi
	#
	#     PS1+="${Reset}@${BBlu}\h ${Pur}\W${BYel}$ ${Reset}"
	# }

if "-e" in sys.argv:
	end_prompt()
else:
	begin_prompt()
